extern const char *pKernel[] =
{
"typedef struct KernelConst_NotEncodedRS\n"
"{\n"
"	int n_points;	/// number of point cloud\n"
"	int n_colors;	/// number of colors per point cloud\n"
"	int n_streams;	/// number of streams\n"
"\n"
"	double scale_X;		/// Scaling factor of x coordinate of point cloud\n"
"	double scale_Y;		/// Scaling factor of y coordinate of point cloud\n"
"	double scale_Z;		/// Scaling factor of z coordinate of point cloud\n"
"\n"
"	double offset_depth;	/// Offset value of point cloud in z direction\n"
"\n"
"	int pn_X;		/// Number of pixel of SLM in x direction\n"
"	int pn_Y;		/// Number of pixel of SLM in y direction\n"
"\n"
"	double pp_X; /// Pixel pitch of SLM in x direction\n"
"	double pp_Y; /// Pixel pitch of SLM in y direction\n"
"\n"
"	double half_ss_X; /// (pixel_x * nx) / 2\n"
"	double half_ss_Y; /// (pixel_y * ny) / 2\n"
"\n"
"	double k;		  /// Wave Number = (2 * PI) / lambda;\n"
"	double lambda;	/// Wave Length\n"
"\n"
"	double det_tx;  /// tx / sqrt(1 - tx^2), tx = lambda / (2 * pp_X)\n"
"	double det_ty;  /// ty / sqrt(1 - ty^2), ty = lambda / (2 * pp_Y)\n"
"} KernelConfig;\n"
"\n"
"__kernel void clKernel_diffractNotEncodedRS(\n"
"	__global double *output, \n"
"	__global double *pc_data, \n"
"	__global double *amp_data, \n"
"	__global KernelConfig *config, \n"
"	const unsigned int cnt, \n"
"	const unsigned int channel) \n"
"{\n"
"	uint width = get_global_size(0); \n"
"	uint col = get_global_id(0); \n"
"	uint row = get_global_id(1); \n"
"	uint idx = width * row + col; \n"
"	float xxx = -config->half_ss_X + (col - 1) * config->pp_X; \n"
"	float yyy = -config->half_ss_Y + (config->pn_Y - row) * config->pp_Y; \n"


"	for (int j = 0; j < cnt; ++j) { \n"
"		int offset = 3 * j; \n"
"		float pcx = pc_data[offset + 0] * config->scale_X; \n"
"		float pcy = pc_data[offset + 1] * config->scale_Y; \n"
"		float pcz = pc_data[offset + 2] * config->scale_Z; \n"

"		pcz = pcz + config->offset_depth; \n"

"		float abs_det_txy_pcz = fabs(config->det_tx * pcz); \n"


"		float _xbound[2] = { pcx + abs_det_txy_pcz, pcx - abs_det_txy_pcz }; \n"
"		abs_det_txy_pcz = fabs(config->det_ty * pcz); \n"
"		float _ybound[2] = { pcy + abs_det_txy_pcz, pcy - abs_det_txy_pcz }; \n"
"\n"
"		float Xbound[2] = { floor((_xbound[0] + config->half_ss_X) / config->pp_X) + 1, \n"
"							 floor((_xbound[1] + config->half_ss_X) / config->pp_X) + 1 }; \n"
"		float Ybound[2] = { config->pn_Y - floor((_ybound[1] + config->half_ss_Y) / config->pp_Y), \n"
"							config->pn_Y - floor((_ybound[0] + config->half_ss_Y) / config->pp_Y) }; \n"


"		if (Xbound[0] > config->pn_X) Xbound[0] = config->pn_X; \n"
"		if (Xbound[1] < 0) Xbound[1] = 0; \n"
"		if (Ybound[0] > config->pn_Y) Ybound[0] = config->pn_Y; \n"
"		if (Ybound[1] < 0) Ybound[1] = 0; \n"

"		if (((col >= Xbound[1]) && (col < Xbound[0])) && ((row >= Ybound[1]) && (row < Ybound[0]))) { \n"

"			float xxx_pcx_sq = (xxx - pcx) * (xxx - pcx); \n"
"			float yyy_pcy_sq = (yyy - pcy) * (yyy - pcy); \n"
"			float pcz_sq = pcz * pcz; \n"
"			float abs_det_txy_sqrt = fabs(config->det_tx * sqrt(yyy_pcy_sq + pcz_sq)); \n"
"			float range_x[2] = { pcx + abs_det_txy_sqrt, pcx - abs_det_txy_sqrt }; \n"
"			abs_det_txy_sqrt = fabs(config->det_ty * sqrt(xxx_pcx_sq + pcz_sq)); \n"
"			float range_y[2] = { pcy + abs_det_txy_sqrt, pcy - abs_det_txy_sqrt }; \n"
"			if (((xxx < range_x[0]) && (xxx > range_x[1])) && ((yyy < range_y[0]) && (yyy > range_y[1]))) { \n"
"				float r = sqrt(xxx_pcx_sq + yyy_pcy_sq + pcz_sq); \n"
"				float p = config->k * r; \n"
"				float amp = amp_data[config->n_colors * j + channel]; \n"
"				float a = (amp * pcz) / (config->lambda * (r * r)); \n"
"				float res_real = sin(p) * a; \n"
"				float res_imag = -cos(p) * a; \n"
"				output[idx * 2 + 0] += res_real; \n"
"				output[idx * 2 + 1] += res_imag; \n"
"			} \n"
"		} \n"
"	} \n"
"}\n"
,
"typedef struct KernelConst_NotEncodedFrsn\n"
"{\n"
"	int n_points;	/// number of point cloud\n"
"	int n_colors;	/// number of colors per point cloud\n"
"	int n_streams;	/// number of streams\n"
"\n"
"	double scale_X;		/// Scaling factor of x coordinate of point cloud\n"
"	double scale_Y;		/// Scaling factor of y coordinate of point cloud\n"
"	double scale_Z;		/// Scaling factor of z coordinate of point cloud\n"
"\n"
"	double offset_depth;	/// Offset value of point cloud in z direction\n"
"\n"
"	int pn_X;		/// Number of pixel of SLM in x direction\n"
"	int pn_Y;		/// Number of pixel of SLM in y direction\n"
"\n"
"	double pp_X; /// Pixel pitch of SLM in x direction\n"
"	double pp_Y; /// Pixel pitch of SLM in y direction\n"
"\n"
"	double half_ss_X; /// (pixel_x * nx) / 2\n"
"	double half_ss_Y; /// (pixel_y * ny) / 2\n"
"\n"
"	double k;		  /// Wave Number = (2 * PI) / lambda;\n"
"	double lambda;	/// Wave Length\n"
"\n"
"	double tx;  /// tx = lambda / (2 * pp_X)\n"
"	double ty;  /// ty = lambda / (2 * pp_Y)\n"
"} KernelConfig;\n"
"\n"
"__kernel void clKernel_diffractNotEncodedFrsn(\n"
"	__global double *output, \n"
"	__global double *pc_data, \n"
"	__global double *amp_data, \n"
"	__global KernelConfig *config, \n"
"	const unsigned int cnt, \n"
"	const unsigned int channel) \n"
"{\n"
"	uint width = get_global_size(0); \n"
"	uint col = get_global_id(0); \n"
"	uint row = get_global_id(1); \n"
"	uint idx = width * row + col; \n"

"	float xxx = -config->half_ss_X + (col - 1) * config->pp_X; \n"
"	float yyy = -config->half_ss_Y + (config->pn_Y - row) * config->pp_Y; \n"

"	for (int j = 0; j < cnt; ++j) { \n"
"		int offset = 3 * j; \n"
"		float pcx = pc_data[offset + 0] * config->scale_X; \n"
"		float pcy = pc_data[offset + 1] * config->scale_Y; \n"
"		float pcz = pc_data[offset + 2] * config->scale_Z + config->offset_depth; \n"

"		float abs_txy_pcz = fabs(config->tx * pcz); \n"
"		float _xbound[2] = { pcx + abs_txy_pcz, pcx - abs_txy_pcz }; \n"

"		abs_txy_pcz = fabs(config->ty * pcz); \n"
"		float _ybound[2] = { pcy + abs_txy_pcz, pcy - abs_txy_pcz }; \n"

"		float Xbound[2] = { floor((_xbound[0] + config->half_ss_X) / config->pp_X) + 1, \n"
"							floor((_xbound[1] + config->half_ss_X) / config->pp_X) + 1 }; \n"

"		float Ybound[2] = { config->pn_Y - floor((_ybound[1] + config->half_ss_Y) / config->pp_Y), \n"
"							config->pn_Y - floor((_ybound[0] + config->half_ss_Y) / config->pp_Y) }; \n"

"		if (Xbound[0] > config->pn_X)	Xbound[0] = config->pn_X; \n"
"		if (Xbound[1] < 0)				Xbound[1] = 0; \n"
"		if (Ybound[0] > config->pn_Y)	Ybound[0] = config->pn_Y; \n"
"		if (Ybound[1] < 0)				Ybound[1] = 0; \n"

"		if (((col >= Xbound[1]) && (col < Xbound[0])) && ((row >= Ybound[1]) && (row < Ybound[0]))) { \n"

"			float amplitude = amp_data[config->n_colors * j + channel]; \n"
"			float p = config->k * ((xxx - pcx) * (xxx - pcx) + (yyy - pcy) * (yyy - pcy) + (2 * pcz * pcz)) / (2 * pcz); \n"
"			float a = amplitude / (config->lambda * pcz); \n"
"			float res_real = sin(p) * a; \n"
"			float res_imag = -cos(p) * a; \n"

"			output[idx * 2 + 0] += res_real; \n"
"			output[idx * 2 + 1] += res_imag; \n"
"		} \n"
"	} \n"
"} \n"
};